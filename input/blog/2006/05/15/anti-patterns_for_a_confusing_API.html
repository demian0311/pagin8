<!--include:disqus.htm-->
<!--include:header.htm-->

<p>Anti-pattern, what a cool name.  It wouldn't be enought to call it just <i>stuff you shouldn't do</i>.  This entry is in the same sarcastic vein as <a href="http://mindprod.com/jgloss/unmain.html">How to Write Unmaintainable code</a>.  That's a great website, every code slinger should read it.  While you're looking for something to read, go read <a href="http://www.amazon.com/gp/product/0201310058/sr=8-1/qid=1148158020/ref=pd_bbs_1/104-8876736-9826321?%5Fencoding=UTF8">Effective Java by Joshua Bloch</a>.  He wrote lots of the Sun Java APIs and points to some warts in some other Sun APIs (presumably ones he didn't write).<br /><ul><br />   <li><span style="font-weight:bold;">Return an un-typed collection like a Vector and don't document the return type</span><br />This isn't as much of a problem now that Java lets you type your collections.  Everyone should take advantage of this.  If you do this without putting specifics in the JavaDocs you have a special level of hell reserved for you.<br />   <li><span style="font-weight:bold;">Require a Properties to make your system usable</span><br />What goes in the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html">Properties </a>object?  I'm looking at JavaDoc right now and they tell you what goes into the  Properties object by referring to another specification.  ....arrr!<br />A Properties object is basically a HashTable that can have any String (usually a constant tucked away somewhere else in the API) as a key and any String as a value.  After my IDE and I look at each other shrugging our shoulders we begin the journey down the rabbit hole to figure out what goes in your Properties object.  What is this buying us?  A well documented bean-like object with setters and getters would be better.<br />   <li><span style="font-weight:bold;">Use integers for constants</span><br />The primitive int is nice and small and you don't have to feel bad when you're sending it around to handle constants.  It's no fun having to debug or maintain code and look at log entries and see a beautifully expressive "3" sitting in your logs.  Maybe it'd be better to see a String with something like "SYSTEM_OFFLINE" or an enum that has it's own description attribute?<br />If you're not using Java 1.5 enums you should read up on using <a href="http://java.sun.com/developer/Books/shiftintojava/page1.html">typesafe enums</a> as recommended by Joshua Bloch in his book <i>Effective Java</i>.<br />When using enums liberally provide descriptions about what they mean, these can be used programmatically to make your API self documenting.<br />   <li><span style="font-weight:bold;">Instantiation Gymnastics</span><br />The <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">factory pattern</a> has to be a good thing right?  It has a name and smart people use it.  I contend that it is over-used.  Perhaps <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> could get rid of 80% of instances of factory patterns in the wild.<br />It's hard to get respect in a room full of geeks when you're the guy saying, "should it really be this complicated."  But really, should using an API be this complicated?  <br />I remember reading a Perl hacker ranting about how he can write a functional Perl script in the time it takes a Java coder to get an instance from an abstract factory singleton after passing in some esoteric properties, yada, yada.  He had a point.<br />   <li><span style="font-weight:bold;">Use Random Naming Conventions</span><br />Why settle for just get[Noun], how about find[Noun], retrieve[Noun], read[Noun].  The opportunity is endless for confusing the users of your API.  I like to write a <a href="http://en.wikipedia.org/wiki/Backus-Naur_form">BNF</a> document for the naming of the public methods in my API and make sure I'm sticking to my own rules.<br />For a persistence API maybe the BNF rules would look something like this.<br /><code><br />methodName ::= [verb][noun]<br />verb ::= create|read|update|delete<br />noun ::= Account|User|Location<br /></code><br />   <li><span style="font-weight:bold;">Don't Practice Test Driven Development</span><br />Just because <a href="http://en.wikipedia.org/wiki/Test_driven_development">TDD</a> is a TLA doesn't mean it's lame.  For the un-initiated <a href="http://en.wikipedia.org/wiki/Test_driven_development">test driven development</a> means writing the tests for your API, maybe even before you write an interface.  IDEs like <a href="http://www.eclipse.org/">Eclipse</a> can make this an interesting experience when they offer to create the interface you are coding to on the fly; slick stuff.<br />Doing TDD makes you the first customer of your API.  You get a chance to see if your API even remotely makes any sense to someone using it.  By doing this first you have less invested in a crappy design and are more likely to tweak it.<br />   <li><span style="font-weight:bold;">Don't Offer a Sensible toString()</span><br />There's nothing more heart-warming than hoping you'll find out the current state of an object only to see it's location in memory.  To someone somewhere I'm sure this is helpful.  In an externally exposed API I say it's un-forgiveable.<br />There's no excuse, you should have toString() implemented for your own use nevermind being useful for others.  Worst case you can use the <a href="http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/builder/ToStringBuilder.html">Jakart Commons ToStringBuilder</a> that uses reflection.<br />   <li><span style="font-weight:bold;">Use Verbose Javadocs Complete With Cool Formatting</span><br />Javadocs, as with well named methods should just say what a method does not how it does it.  If you have code that is so confusing that you need to explain how it does something first consider pulling out some of the functionality into another well named method.  I'm going off on a tangent, that's not stuff an API user sees.<br />The point here is that if you write a long multi-paragraph javadoc along wiht some cute formatting you are quickly decreasing the likelyhood that the javadocs will be maintained.  As a maintainer just trying to refactor code or fix defects you don't want to spend 10 minutes absorbing your long comments, re-writing them and possibly re-formatting them.<br />So, keep it short, if you've written your API such that you need long comments think hard about how you can improve the usability of your API.<br />   <li><span style="font-weight:bold;">Show the World How Sausage is Made</span><br />No one wants to know all the ugly things you're calling or have exposure to all of your dependencies.  This makes the calling system coupled to the same crap your API is coupled to.  This is of course referring to the <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">law of demeter</a>.<br />The bottom line is that if you expect your API users to do something like this:<br /><code><br />boolean isNorthAmerica = yourObject.getEmployee().getAddress().getCountry().isNorthAmerica();<br /></code><br />...that's a bad thing.<br /></ul></p>


<p>Anti-pattern, what a cool name.  It wouldn't be enought to call it just <i>stuff you shouldn't do</i>.  This entry is in the same sarcastic vein as <a href="http://mindprod.com/jgloss/unmain.html">How to Write Unmaintainable code</a>.  That's a great website, every code slinger should read it.  While you're looking for something to read, go read <a href="http://www.amazon.com/gp/product/0201310058/sr=8-1/qid=1148158020/ref=pd_bbs_1/104-8876736-9826321?%5Fencoding=UTF8">Effective Java by Joshua Bloch</a>.  He wrote lots of the Sun Java APIs and points to some warts in some other Sun APIs (presumably ones he didn't write).<br /><ul><br />   <li><span style="font-weight:bold;">Return an un-typed collection like a Vector and don't document the return type</span><br />This isn't as much of a problem now that Java lets you type your collections.  Everyone should take advantage of this.  If you do this without putting specifics in the JavaDocs you have a special level of hell reserved for you.<br />   <li><span style="font-weight:bold;">Require a Properties to make your system usable</span><br />What goes in the <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html">Properties </a>object?  I'm looking at JavaDoc right now and they tell you what goes into the  Properties object by referring to another specification.  ....arrr!<br />A Properties object is basically a HashTable that can have any String (usually a constant tucked away somewhere else in the API) as a key and any String as a value.  After my IDE and I look at each other shrugging our shoulders we begin the journey down the rabbit hole to figure out what goes in your Properties object.  What is this buying us?  A well documented bean-like object with setters and getters would be better.<br />   <li><span style="font-weight:bold;">Use integers for constants</span><br />The primitive int is nice and small and you don't have to feel bad when you're sending it around to handle constants.  It's no fun having to debug or maintain code and look at log entries and see a beautifully expressive "3" sitting in your logs.  Maybe it'd be better to see a String with something like "SYSTEM_OFFLINE" or an enum that has it's own description attribute?<br />If you're not using Java 1.5 enums you should read up on using <a href="http://java.sun.com/developer/Books/shiftintojava/page1.html">typesafe enums</a> as recommended by Joshua Bloch in his book <i>Effective Java</i>.<br />When using enums liberally provide descriptions about what they mean, these can be used programmatically to make your API self documenting.<br />   <li><span style="font-weight:bold;">Instantiation Gymnastics</span><br />The <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">factory pattern</a> has to be a good thing right?  It has a name and smart people use it.  I contend that it is over-used.  Perhaps <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> could get rid of 80% of instances of factory patterns in the wild.<br />It's hard to get respect in a room full of geeks when you're the guy saying, "should it really be this complicated."  But really, should using an API be this complicated?  <br />I remember reading a Perl hacker ranting about how he can write a functional Perl script in the time it takes a Java coder to get an instance from an abstract factory singleton after passing in some esoteric properties, yada, yada.  He had a point.<br />   <li><span style="font-weight:bold;">Use Random Naming Conventions</span><br />Why settle for just get[Noun], how about find[Noun], retrieve[Noun], read[Noun].  The opportunity is endless for confusing the users of your API.  I like to write a <a href="http://en.wikipedia.org/wiki/Backus-Naur_form">BNF</a> document for the naming of the public methods in my API and make sure I'm sticking to my own rules.<br />For a persistence API maybe the BNF rules would look something like this.<br /><code><br />methodName ::= [verb][noun]<br />verb ::= create|read|update|delete<br />noun ::= Account|User|Location<br /></code><br />   <li><span style="font-weight:bold;">Don't Practice Test Driven Development</span><br />Just because <a href="http://en.wikipedia.org/wiki/Test_driven_development">TDD</a> is a TLA doesn't mean it's lame.  For the un-initiated <a href="http://en.wikipedia.org/wiki/Test_driven_development">test driven development</a> means writing the tests for your API, maybe even before you write an interface.  IDEs like <a href="http://www.eclipse.org/">Eclipse</a> can make this an interesting experience when they offer to create the interface you are coding to on the fly; slick stuff.<br />Doing TDD makes you the first customer of your API.  You get a chance to see if your API even remotely makes any sense to someone using it.  By doing this first you have less invested in a crappy design and are more likely to tweak it.<br />   <li><span style="font-weight:bold;">Don't Offer a Sensible toString()</span><br />There's nothing more heart-warming than hoping you'll find out the current state of an object only to see it's location in memory.  To someone somewhere I'm sure this is helpful.  In an externally exposed API I say it's un-forgiveable.<br />There's no excuse, you should have toString() implemented for your own use nevermind being useful for others.  Worst case you can use the <a href="http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/builder/ToStringBuilder.html">Jakart Commons ToStringBuilder</a> that uses reflection.<br />   <li><span style="font-weight:bold;">Use Verbose Javadocs Complete With Cool Formatting</span><br />Javadocs, as with well named methods should just say what a method does not how it does it.  If you have code that is so confusing that you need to explain how it does something first consider pulling out some of the functionality into another well named method.  I'm going off on a tangent, that's not stuff an API user sees.<br />The point here is that if you write a long multi-paragraph javadoc along wiht some cute formatting you are quickly decreasing the likelyhood that the javadocs will be maintained.  As a maintainer just trying to refactor code or fix defects you don't want to spend 10 minutes absorbing your long comments, re-writing them and possibly re-formatting them.<br />So, keep it short, if you've written your API such that you need long comments think hard about how you can improve the usability of your API.<br />   <li><span style="font-weight:bold;">Show the World How Sausage is Made</span><br />No one wants to know all the ugly things you're calling or have exposure to all of your dependencies.  This makes the calling system coupled to the same crap your API is coupled to.  This is of course referring to the <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">law of demeter</a>.<br />The bottom line is that if you expect your API users to do something like this:<br /><code><br />boolean isNorthAmerica = yourObject.getEmployee().getAddress().getCountry().isNorthAmerica();<br /></code><br />...that's a bad thing.<br /></ul></p>
<!--include:disqus.htm-->
<!--include:footer.htm-->
